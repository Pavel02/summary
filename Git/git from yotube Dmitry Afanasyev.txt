<?php

/**
 *      $ git init      // Инициализация локального репозитория
 *
 *      $ git config --global user.name "Pavel"         // Задаем глоб настройки
 *      $ git config --global user.email foo@mail.ru    //
 *      $ git config --list                     // Вывод значений всех настроек (также c/users/Имя/.gitconfig)
 *
 * Игнорирование файлов в GIT
 * В репозитории создается файл ".gitignore". В нем пишем
 *                                               logs/        (исключ каталог logs)
 *                                               docs/*.txt   (исключ в каталоге docs файлы с расшир txt)
 *
 *      $ git status
 *      $ git status --untracked-files-all      // Покажет все файлы вне зоны контроля
 *
 *      $ git add .             // Все файлы untracked добавятся в индекс
 *
 *      $ git rm --cashed LICENSE.PHP   // Файл LICENSE.PHP переведется в статус untracked
 *
 *      $ git add *.php         // Будут добавлены в индекс все модифицированные файлы с расширеним php
 *
 *      $ git checkout --LICENSE.PHP    // Откатит данный файл к состоянию которое закреплено в репо
 *
 *
 *      $ git commit -m""           // Создание коммита
 *      $ git log                   // Получение истории коммитов
 *      $ q                         // Выход из огромной истории коммитов
 *
 *      $ git help log              // Получение подсказки по команде log
 *
 *      $ git log --pretty-format: "%h - %an.Xar : %3"      // Пользовательский вывод инфо о коммитах
 *      $ git log --since-2.weeks       // История коммитов за последние 2 недели.
 *
 *      $ git log -p -2                 // Показ 2-х последних коммитов и какие изменения были до и после
 *
 *      $ git commit        // если без ключа -m то откороется Vi
 *                          // Можно по умолчанию в WIN добавить Notepad ++
 *      $ git config --global core.editor "'D:\Program Files\Notepad++\notepad++.exe' -multiInst -notahbar -nosession -noPlugin"
 *
 *
 * Ветки
 *      $ git checkout -b new_f         // Создание новой ветки и сразу переход в нее
 *
 *      $ git branch                    // Просмотр имеющихся веток
 *      $ git branch -v                 // Подробный просмотр имеющихся веток
 *
 *      $ git branch new_f2             // Создание новой ветки без перехода в нее
 *      $ git checkout new_f2           // переход на ветку new_f2
 *
 * Мерж веток
 *      $ git config --global merge.tool kdiff3     // Объявляем инструмент для мержа веток
 *
 *      $ git merge master              // Будем заливать ветку master, находясь в другой ветке
 *      $ git mergetool                 // Указываем гиту запустить утилиту для мержа
 *   утилита kdiff3 скачивается для WIN отдельно
 *   после загрузки и установки, прописываем ее в bash
 *      $ git config --global mergetool.kdiff3.cmd '"C:\\Program Files\\KDiff3\\kdiff3" $BASE $LOCAL $REMOTE -o $MERGED'
 *              // В файле настроек С:\USERS\name_user\.gitconfig   будет это прописано
 *
 *
 * GitHub
 *      $ git remote add origin https://.......... .git     //создание удален репо с имненм origin
 *
 *      $ git remote                            // Покажет какие есть репозитории
 *      $ git remote -v                         // Подробно покажет какие есть репозитории
 *
 *      $ git help remote       // подсказка по команде remote
 *
 *      $ git push -u origin master     // Все закомиченные изменения из лок репо будем проталкивать в удаленный репо
 *                                      // с именем origin (и проталкиваем ветку мастер)
 *                                      // ключ -u чтобы по умолчаию пушилось в origin
 *      $ git config --global push.default simple   // Данная настройка стоит по умолчанию
 *                                                  // На удаленный репо будет пушиться ТА ветка на которой находимся
 *      $ git config --global push.default matching   // На удаленном репо есть сведения о 2-х ветках, а на локальном
 *                                                    // репо есть 4 ветки. Пушиться будут сразу две.
 *
 *      $ git clone https://github.com/......... .git   // Копирование содержимого из удаленного репо.
 *
 *      $ git fetch         // Узнает информацию об изменениях на удаленном репо.
 *      $ git pull          // Забирает изменения из удаленного репо
 *
 *      $ git pull ProfIT master        // Забирает изменения с репо (под псевдонимом PrifIT который ранее указали) и ветку master
 *
 *
 *
 *
 *
 *
 *
 * "Аварийные инструменты" в GIT. Используйте их только для своего локального репозитория.
 * Не рассматривайте GIT, как хранилище файлов.
 * git это инструмент коллективной работы.
 *
 *      $ git commit --amend    // "Догоняет" последний коммит. Используется, чтобы добавить в последний
 *                              // коммит забытые изменения или изменить его message.
 *                              // Все подоготовленное для фиксации будет зафиксировано в последнем коммите.
 *
 *      $ git reset HEAD ФАЙЛ   // Отмена индексации, то есть отмена подготовки файла к фиксации. Сам файл не именяется.
 *                              // т.е. подготовили файлы в индекс и перед комитом. решили какой-то убрать из индекса.
 *
 *      $ git checkout -- ФАЙЛ      // Сброс файла к состоянию последнего коммита.
 *
 *
 *      $ git reset --soft КОММИТ       // "Мягкий" откат репозитория в состояние указанного коммита.
 *                                      // Все изменения, бывшие ранее коммитами после указанного, останутся в индексе.
 *                                      // И вы сможете снова их зафиксировать.
 *                                      // Файлы не изменятся. Все что было после указанного коммита станет незафиксированными изменениями.
 *
 *      $ git reset --hard КОММИТ       // Откат репозитория в состояние указанного коммита.
 *                                      // Файлы откатываются к состоянию коммита.
 *                                      // Коммиты после указанного пропадают из git log, но на самом деле все еще хранятся
 *      $ git log                    // История коммитов
 *      $ git reflog                // История того, что вы делали со своим репозиторием.
 *
 * Есть возможность переместить репозиторий вообще к любому состоянию, указанному в git reflog
 *      $ git reset --hard HEAD@{3}     // Переместит в эту контрольную точку. И это уже окончательно
 *
 *      $ git rebase            // перемещение изменений из одной ветки в другую
 *                              // rebase применяет одно изменение за другим в одну ветку.
 *                              // После rebase остаются плоская линейная история. Как будто и не было ветвления.
 *                              // Не перемещайте коммиты, которые вы уже отправили в публичный репо.
 *      $ git rebase -i HEAD~5   // откатываемся на 5 коммитов назад, и в редакторе помечаем, что мы хотимсделать с коммитом
 *
 *      $ git stash         // Спрячет все назафиксированные изменения в своеобрзный буфер
 *      $ git stash apply   // Достанет изменения из буфера
 *      $ git stash NAME    // Создаст буфер с NAME. Их так может быть много.
 *
 *
 * ТЕГИ - это метки, которыми можно пометить коммит. Это имя для коммита. Часто помечают коммит, именуя версию продукта.
 *      $ git tag 1.0       // Текущий коммит помечается меткой 1.0
 *      $ git tag           // Вывод всех меток в нашем репо
 *      $ git tag -l '1.*'  // Список меток по маске (например 1.*)
 *      $ git show 1.0      // Просмотр информации о заданной метке
 *      $ git tag -d 1.0    // Удаляет метку. Разумеется, коммит не удаляется.
 * Выше представлены легковесные (легкие) метки. Существует еще аннотированное метки
 *      $ git tag -a 1.0 -m "Сообщени"      // Фиксируется сообщение, дата, имя создавшего. Возможна еще цифровая подпись.
 *      $ git tag -a 1.0 -m "Сообщение" 1baf    // Указав хеш коммита мы присвоим именно ему tag
 *
 * По умолчанию метки не передаются в удаленный репо.
 *      $ git push origin 1.0       // Пушится определенный тег
 *      $ git push origin --tags    // Пушатся все имеющиеся метки
 *
 * СУБМОДУЛИ
 *  Это фактически, репозиторий внутри вашего репозитория.
 *      $ git submodule add РЕПОЗИТОРИЙ ПАПКА   // Добавляет в ваш репо субмодуль.
 *                                              // Выглядит субмодуль как папка, связанная с другим удаленным репо.
 *                                              // После добавления субмодуля нужно зафиксировать изменения коммандой git commit
 *                                              // В папке будет полный клон удаленного репо.
 *      $ git submodule init            // Инициализирует субмодули в репозитории, где это еще не сделано (например сразу после клонирования)
 *      $ git submodele update          // Загружает файлы субмоделей
 *
 *
 * GIT FLOW это формальное описание как работать с ветками в GIT.
 * Это не стандарт, а предмет для дискусси. при этом
 *  ветка master  - стабильная ветка, соответствует состояюнию продакшна. Каждый коммит здесь переводит наш проект из одного состояния в другоею
 *                  Данная ветка никогда не коммитится напрямую. В этой ветке как правило присутствуют ТЕГи и о версиях ПО.
 *  ветка hotfix/..  - Для исправления чудовищной ошибки в ветке master, создается hotfix и мержим в master
 *  ветка develop   - грязная ветка для разработки нового функцианала. переодически сюда заливается ветка master.
 *                  , чтобы develop соответсвовала стабильной ветке master
 *  ветки feature/№задачи   - образованы от ветки develop, в них проходит разработка определенного функционала.
 *                             когда задача решена ветки feature мержатся в develop.
 *  ветки release   - когда в develop накапливается достаточно изменений, то запускается release. тестирование, исправление ошибок и
 *                    выкладывается на master.
 *
 * Есть набор команд GIT FLOW http://danielkummer.github.io/git-flow-cheatsheet/index.ru_RU.html
 *
 *
 *
 *
 *
 *

 *
 */