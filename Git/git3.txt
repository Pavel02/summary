<?php
/**
 * Created by PhpStorm.
 * User: User
 * Date: 016 16.01.17
 * Time: 15:14
 */

/**
 * Ветвление в GIT
 * Репозиторий хранит в себе информацию о состояниях репозитория. Они называются "Снапшоты".
 * "Снапшот" - это информацио о том, каким был репо в тот или иной момент времени.
 * В отличие от других систем контроля, это не разница между состояниями (не набор изменений),
 *      а именно снимок всех папок, файлов и т.д.
 * Снапшот создается вовремя коммита.
 * Каждое состояние - это коммит. Коммит - это снапшот и данные об авторстве.
 * Каждый коммит хранит полное состояие о файловой системе репо.
 * Можно быстро восстановить состояние 20 коммитов назад. Если промежуточный коммит быит, то можно восстановить предыдщий.
 *
 * Коммит снабжен указателем на родителя. Ноль - если это первый коммит. Один - если это обычный.
 *
 * Коммит - снимок файловой системы (копия всех файлов) + инфа об авторе номере и времени коммита + указатель на род коммит
 * Каждый комит это момет времени, и ссылка на предыдущий.
 *
 * bare - голый репозиторий. Не храит файлов, а хранит снэпшоты.
 *
 *
 * Ветка в git - это просто указатель на какой-то один из коммитов в истории
 * При создании репо автоматически создается ветка master
 * Ветка master (то есть указатель) автоматически сдвигается вперед при каждом коммите.
 * Когда мы говорим, что находимся в ветке master, это значит, что РЕПО находится в том состоянии,
 *      которое соответсвует коммиту, на который указывает master.
 *
 *      $ git branch testing    // создается новый указатель testing, указывающий на коммит в котором мы находимся.
 *                              // Больше ничего эта команда не делает. Только новый указатель.
 *
 * Git хранит специальный указатель, который называется HEAD
 * Это указатель на текущую ветку и коммит. HEAD - это указатель на указатель.
 * По сути HEAD это указатель на текущее состояние репозитория.
 *      $ git checkout testing  // Эта команда передвинет HEAD на ветку testing
 *                              // То есть переключит репозиторий на другую ветку
 *
 * Делаем коммиты в ветке testing
 *      $ git checkout master  //  Вернувшись в ветку master, мы не увидим коммиты ветки testing
 *
 *
 * Слияние веток.
 * Fast-forward  - когда объединяемые ветки находятся на одной лини истории.
 * По сути FF перематывает историю вперед. Перемещает указатель на последний по времени коммит веток.
 *      $ git checkout -b hotfix    // Создается ветка HOTFIX и сразу переключение на нее. Поработали сделали заплатку.
 *      $ git checkout master       // Перешли на ветку мастер.
 *      $ git merge hotfix          // Объединили 2 ветки. Будет использоваться метод Fast-forward
 *      $ git branch -d hotfix      // Удаляем ненужную ветку
 *
 * Обычно ветку для задачи можно назвать так  feature/GO-1285   (Задачча/кр наза проекта - № задачи)
 *
 *      $ git branch -v             // Покажет какие есть ветки
 *
 * Рекурсивная стратегия объединения - когда 2 ветки не находятся на одной линии истории. Коммиты разошлись в разные стороны.
 * В этом случае GIT применяет алгоритм наилучшего общего предка.
 * От обоих веток, назад по истории коммитов просматривает историю, пока не найдет близжайшего к нимм общего предка.
 * После чего начинает к этомупредку последовательно применять коммиты, ориентируюсь на их время создания.
 * И в результате создается НОВЫЙ КОММИТ - слияние.
 * При рекурсивном объединении может попасть редактор Vi.
 *      Esc :w -записать изменения
 *      Esc :q - выход
 *
 * Ветки в Git это штатное средство.
 * Нужно внести изменение в проект - сделайте ветку, напишите код, потестируйте его.Если ок, то объдините с master.
 * Одна задача - одна ветка.
 *
 * В Git конфликт это призыв к Вам, что он не смог автоматически слить ветки, пожалуйста, сделайте это вручную.
 * Конфликт - это невозможность слияния из-за неодназначности.
 * В случае, если делаем мерж 2-х веток напрямую в консоли и возникает конфликт, то переходим к указанному файлу ->
 *   вручную исправляем конфликт в каком либо редакторе -> индексируем файл -> делаем коммит.
 * Решение конфликтов - это та часть "Дао Git", в котором рекомендация пользоваться графическими инстрментами
 *
 *
 * Вопрос про БД. pr-of-it.ru/webinars/5.html
 * Миграции. Yii, команда migrate
 *
 *
 *
 *
 *
 *
 * 
 * 
 * 
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *      $ git remote add NAME PATH  //Добавляем к текущем репо ссылку на удаленный(можем другую папку на нашем же ПК или облако)
 *      $ git remote add PHP2 C:\Server\domains\php2.local  //Новый репо с именем РНР2 с адресом
 *
 *      $ git remote    // Покажет список имеющихся удаленных прикрепленных реппозиториев
 *      $ git remote -v     // Подробный показ имеющихся репо (покажет адрес)
 *      $ git remote show NAME      // Вся инфа об репо с именем NAME
 *
 *
 *      $ git fetch NAME    // Возьмет информацию обо всех изменениях в удаленном репо и перенесет в наш репо
 *                          //(Например список веток, коммитов и т.д)
 *                          // Локальный репо не изменится. Мы только узнаем все об удаленном репо
 *
 *      $ git checkout --track NAME/master      // Создается связь нашего лок репо с всеткой мастер удаленного репо имени NAME
 *
 *      $ git checkout --track php2/master
 *         // например такая надпись будет
 *         // Branch master set up to track remote branch master from php2
 *
 *      $ git pull      // получение изменений
 *
 * На GitHub у нас есть репозиторий
 *      $ git clone CLONE_URL PROJECT_FOLDER
 *      $ git clone https://github.com/Pavel02/test.git test
 *              // На локальном репо создатся test и в нее скопируется все из GitHub
 *              // Полная копия удаленного репозитория локально. И автоматом устанавливается между ними СВЯЗЬ
 * Клонировать можно только существующий репо в ПУСТУЮ папку
 *
 *
 *      $ git push  // Берет имеющиеся локальные изменения и отправляет их в удаленный репо
 *
 *      $ git pull  // Вытенет изменения из удаленного репо и пытается их применить к нашему локальному
 *                  // Влить удаленную ветку в локальную
 * Принцип Unix-way - Программа должна выполнять одно дело, но выполнять его хорошо
 * Задача GIT вести историю изменения файлов, он показывает разницу между двумя состояниями файла. А другие программы эту разницу могут интерпретировать.
 *
 *
 *
 *
 *
 *
 */