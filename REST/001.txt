
https://www.youtube.com/watch?v=jDj_JggZXsU			Построение и тестирование REST API в Yii2 (мастеркласс на 6 часов примерно от 31.01.2017)
	
	
	Есть проблема: взаимодействия между сайтами и приложениями в интеренте. (если локальная сеть, то через сокеты)
		В интеренете не удобно низко уровневое подключение по портам (блочат бредмаузеры и т.д.)
		Есть сервер (на РНР node.js ) на чем угодно и есть клиенты (другие сайты, мобильные приложения и т.д.) 
		Проблема унификации запросов, чтобы не зависело от реализации клиентов.
		
	
	HTTP 		GET /users/5				// клиент посылает запрос (например браузер)
				
						HTTP 200 OK					// Ответ сервера
						
						<html>.....</html>			// текст отданный сервером 
						
	Внешний клиент теперь связывается по HTTP как обычный браузер. 
	
	Как связать компьютеры?  	API
	 Для браузера сервер отдает html , для других клиентов нужны текстовые форматы, которые могли бы 
	  объекты, массивы отображать как текст и передавать по HTTP.  так например XML, JSON и т.д.
	  
	
Какие API есть?
	XML-RPC - Remote Procedure Call			протокол удаленного вызова процедур (запросы и ответы будут формироваться в XML)
		на сервере имеется какая-либо функция , например getPost($id) { ..... } 
		для сериализации используются объектов используюется XML 
		
		пример http://gggeek.github.io/phpxmlrpc    // Описание реализации XML-RPC for PHP
				http://phpxmlrpc.sourceforge.net/server.php 
				
		При RPC  для запроса параметры формируются в XML в соответсвии с документацией к API сервера,
		 ответ нам приходит в виде того же XML и мы его должны распарсить. 
		 
		Неудобство: со стороны сервера обязательна должна быть документация, потому что иначе сторонний разработчик
		 не сможет понять какие методы есть, и как именно формировать XML для передачи параметров.
		 
		 
	SOAP - Simple Object Access Protocol
		изначально придумали, как простой протокол доступа к удаленным объектам, но в итоге XML здесь 
		 получаются непростые и низкоуровнево (руками) с ними лучше не работать.
		
		пример сайта БР http://cbr.ru/DailyInfoWebServ/DailyInfo.asmx 		// Здесь описание API, но если добавим параметр ?WSDL 
						http://cbr.ru/DailyInfoWebServ/DailyInfo.asmx?WSDL   // описаиние ввиде xml документацией
	
		WSDL - Web Services Description Language - Описывает Web-сервисы 
		
	
			Здесь XML получается далеко не простым. Можем передавать объекты через формат 
		JSON - JavaScript Object Notation. 
							var m = {
								id: 5,
								title: "Title"
							};
							
	JSON-RPC	
		обычный RPC но сериализация объектов через формат JSON.
		Здесь тела запросов и ответов становятся в разы короче и читабельнее.
		 Но теряется описательный файл, со всеми нашими методами и параметрами, нам придется такую документацию с 
		 примерами вызовов прописывать вручную.
		 Но при этом для JS формат JSON нативный и удобный.
		
		JSON-Schema  появился как аналог WSDL файла, чтобы разработчики могли знать какие методы и параметры имеются на сервере.
		 
см. 00:45:25  краткое но емкое резюме 3 выше рассмотренных методов.
		 
_________________________________________________________________________		 
		 
	REST - Representational State Transfer — «передача состояния представления». 
		Это некий архитектурный стиль. некий образ мышления. Нет строгой стандартизации. Набор рекомендаций.
			https://ru.wikipedia.org/wiki/REST
		
		1. Модель клиент-сервер. 
			Имеется сервер, Разные приложения Клиенты подключаются и либо что-то кладут, либо что-то запрашивают.
		
		2. Отсутствие состояния.
			Когда мы залогинились на сайте и переходим по страницам, то Сервер хранит состояние залогинности хранит
			 у себя в сессии или куках, а ключ передает через куки. 
			При REST между запросами клента никакой информации о состоянии (залогинности или чего либо друго) клиента Сервер Не хранит.
			Вместо этого Клиент каждый раз передает Серверу нужные айдишники о себе.
			Нет такого, чтобы сервер что-сохранил у себя и использовал эту инфу при след. обращенни Клиента.
				Может быть распределенная система серверов. При обращении к любому из них должно быть единообразие.
				
		3. Кеширование
		
		4. Единообразие интерфейса.
			Каждый ресурс идентифицируется в запросе по уникальному URI адресу.
			
			
		REST основан на ресурсах (Идентификация ресурсов) 
		Отдельные ресурсы определяются в запросе, для чего используются URI, как идентифкатор ресурсов. А не по полям в теле.
		Одна ссылка - один ресурс.
		
			
	т.е. XML-RPC запрос POST отправляется на единый адрес  ( например /api) а в теле через xml указываем название метода и параметры метода.
	 а в REST уникальный метод - уникальный URI. Теперь название метода нигде не фигурирует. Используются адреса и заголовки.
	
				
			======= REQUEST =====
			
			GET /posts/1 HTTP/1.1
			Host: site.com
			Accept: application/json 				// Здесь Клиент указывает Серверу, данные в каком формате ему вернуть.
													// Accept: text/xml 
			Accept-Language: en
			
		Можем кроме заголовка GET можем разные заголовки  
			
			GET /posts				получене списка всех постов
			POST /posts				создание нового поста
			GET /posts/123 			получить пост с id  равным 123 
			PUT|PATCH /posts/123 	изменение поста с id равным 123			//put полностью меняет пост, а patch редактировать. но на практике их делают эквивалентными на сервере 
			DELETE /posts/123 		удаление поста с id равным 123 
			 
		Если CRUD приложение, то через эти заголовки уже реализация.
		
		Методы ниже возвращают метаданные
			HEAD /posts				получене метаданных списка (сколько постов) 
			HEAD /posts/123			получение метаданных поста с id равным 123			 
			OPTIONS /posts			получение поддерживаемых методов, по которым можно обратиться к /posts (массив гетов, постов и т.д.
			OPTIONS /posts/123		получение поддерживаемых методов, по которым можно обратиться к /posts/123
		 
	Все вещи на сайте начинают реализовываться в виде ресурсов по уникальным адресам 
	
	Теперь клиенты могут использовать обычные эмуляторы браузеров или HTTP клиенты, без изобретения велосипедов.
	
	Кроме HTTP запросов, мы можем использовать разные HTTP статусы (возврат от сервера)
	
		403 	forbidden отказано в доступе
		404 	not found
		200 	ок
		
		2xx		успех
		5хх		ошибка сервера
		4хх		ошибка клиента 
		
	т.е. из HTTP в реальной жизни используем адреса для идентификации ресурсов, 
		методы запросы GET, HEAD и тд для действия с ресурсами,
		статусы сервера (получилось или нет).
		
_________________________________________________________________________

	GET - идемпотентность ( сколько бы раз мы не применили метод GET, то ничего не поменяется)
	PUT {status: 3}  	(один раз переименовали стату в значение 3, после сколько бы на вызывали статус теперь будет 3)
	DELETE posts/1		(один раз удалили, а после сколько раз не обращаемся уже ничего не изменится)
	
	POST /posts		не является идемпотентным (сколько обратимся, столько будет новых статей)
							
	
	GET - безопасный метод (можем не делать проверку на права пользователя)
	
	
	Если мы будем авторизоваться, то данные авторизации будем передавать в каждом запросе, а не сохранять их куда-то на 
	 сервер, поэтому доаже если система из 20 серверов, подключенных к одной БД, то ничего не сломается.
	 
_________________________________________________________________________

	Гипермедиа HATEOAS
	В теле ответа от сервера мы можем задавать дополнительные ссылки, помогающие понять по какому адресу можно 
	 обратиться к нужному ресурсу
						<item id="12" productId="7" amount="4">
							<link rel="self" uri="/orders/1/items/12" />
							<link rel="product" uri="/product/7" />
						</item>
	
_________________________________________________________________________
		
	Дполнительными параметрами в запросе мы мыожем уточнять запрос.
		GET /posts?sort=-id HTTP/1.1			здесь доп параметр говорит, что сортировка по убыванию id
		
	
	Если мало постов, то можем сразу их все вернуть, а если много, то надо реализовать пагинацию
	Сделать это можно с помощью заголовков отдаваемых сервером.
							X-Pagination-Total-Count: 103
							X-Pagination-Page-Count: 11
							X-Pagination-Current-Page: 1
см. 01:44:40							и т.д.
	при этом информацию о погинации можно и в тело ответа для удобства работы AJAX
	
	
	Аутентифкация
		по работе по API нет сессии. Идентификатор нужно передавать каждый раз.
		
		сервер выдает клиенту токен, а потом
		в заголовоках передаем			
			Authorization: Bearer we234hsdfie847fdfkvjhf
			
			
_________________________________________________________________________

	
	Например была у нас в апиай такой роут		 api.site.com/users/1   но приложение развилось 
	 и мы удалили идентификацию  по  user и сделали например так  api.site.com/post/1 
	 Теперь отвалятся например старые приложения не обновленные из appstore. Не станут работать пока не обновятся.
	 Нужно ввести некоторое версионирование.
					api.site.com/v1/users/1 
					api.site.com/v2/users/1 
					api.site.com/v3/users/1 
	можно обратиться к api по новой версии v2,  но старая  v1  продолжает поддерживаться.
	
	Также вариант, что версионность может быть организована в виде параметров к основному адресу.
					api.site.com/users/1?version=1.5
	
	Если api будем делать только для своих внутренних нужд, то такие заморочки ненужны, 
	 а если  api  будет доступен для других пользователей (клиентов) то все заморочки (версионность) уже нужны. 
	 
	Помимо передачи версии в самом адресе, можем передавать версию в заголовке Accept.
					Accept: application/json; version=v1.3
					
	Условный   Microsoft для своей внутренней api  может поступать так: 
					Accept: application/vnd.company.app-v1+json
	
_________________________________________________________________________	
	
	RESTFul  -  любой Веб сервис, любой API (эйпиай), которые подходят под те принципы, которые требует 
				рест называются RESTFul (Значит api полностью удовлетворяют всем условиям и требованиям, 
				которые на нее накладывает REST)
	
	
_________________________________________________________________________

	Как получают токен на моб приложение? 
		Заходят в моб приложение, сразу выскакивает форма логина. 
		Туда логин пароль, которые отправляются на сервер, оттуда токен, 
		который приложение записывает в  storage. И далее передает этот токен в каждом запросе. 
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	